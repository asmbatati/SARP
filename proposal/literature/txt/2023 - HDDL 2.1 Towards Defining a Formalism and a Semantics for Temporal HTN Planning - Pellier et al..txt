--- Page 1 ---
arXiv:2306.07353v1  [cs.AI]  12 Jun 2023
HDDL 2.1: Towards Deﬁning a Formalism and a Semantics
for Temporal HTN Planning
Damien Pellier,1 Alexandre Albore,2 Humbert Fiorino,1 Rafael Bailon-Ruiz 2
1University of Grenoble Alpes, LIG, Grenoble, France
{damien.pellier, humbert.ﬁorno}@imag.fr
2ONERA/DTIS, University of Toulouse, France
{alexandre.albore, rafael.bailon ruiz}@onera.fr
Abstract
Real world applications as in industry and robotics need mod-
elling rich and diverse automated planning problems. Their
resolution usually requires coordinated and concurrent ac-
tion execution. In several cases, these problems are naturally
decomposed in a hierarchical way and expressed by a Hi-
erarchical Task Network (HTN) formalism. HDDL, a hier-
archical extension of the Planning Domain Deﬁnition Lan-
guage (PDDL), unlike PDDL 2.1 does not allow to represent
planning problems with numerical and temporal constraints,
which are essential for real world applications. We propose to
ﬁll the gap between HDDL and these operational needs and to
extend HDDL by taking inspiration from PDDL 2.1 in order
to express numerical and temporal expressions. This paper
opens discussions on the semantics and the syntax needed for
a future HDDL 2.1 extension.
1
Introduction
Real world applications of Automated Planning, like in in-
dustry and robotics, require modelling rich and diverse sce-
narios. Such planning problems are often naturally decom-
posed in a hierarchical way, with compound tasks that reﬁne
in different ways their execution model. These real world ap-
plications of planning use both numerical and temporal con-
straints to deﬁne the agents synchronisation on collabora-
tive tasks, and sub-task decomposition. In fact, concurrency
between actions, their duration, and agents coordination in
HTN problems are needed to ﬁnd solutions for nontrivial
tasks in complex scenarios and require to make explicit the
representation of time (Ghallab, Nau, and Traverso 2016).
The Hierarchical Task Network (HTN) formalism (Erol,
Hendler, and Nau 1994) is used to express a wide variety
of planning problems in real-world applications, e.g., in task
allocation for robot ﬂeets (Milot et al. 2021), video games
(Menif, Jacopin, and Cazenave 2014) or industrial contexts
such as software deployment (Georgievski et al. 2017). Over
the last years, much progress has been made in the ﬁeld of
hierarchical planning (Bercher, Alford, and H¨oller 2019).
Novel systems based on the traditional, search-based tech-
niques have been introduced (Bit-Monnot, Smith, and Do
2016; Ramoul et al. 2017; Shivashankar, Alford, and Aha
2017; Bercher et al. 2017; H¨oller et al. 2019, 2020; H¨oller
and Bercher 2021), but also new techniques like the transla-
tion to STRIPS/ADL (Alford, Kuter, and Nau 2009; Alford
et al. 2016; Behnke et al. 2022), or revisited approaches like
the translation to propositional logic (Behnke, H¨oller, and
Biundo 2018, 2019; Schreiber et al. 2019; Schreiber 2021;
Behnke 2021). Despite these advances, not all planning sys-
tems use the same formalism to represent hierarchical task
decomposition, making it difﬁcult to compare approaches
and promote HTN planning techniques.
An extension of PDDL (Planning Domain Description
Language) (Mcdermott et al. 1998), called HDDL (Hier-
archical Planning Domain Description Language) (H¨oller
et al. 2020), has been proposed to address this issue. HDDL
is based on PDDL 2.1 (Fox and Long 2003) and is the
result of several discussions within the planning commu-
nity (Behnke et al. 2019) to ﬁll the need of a standard lan-
guage for the ﬁrst Hierarchical Planning track of Interna-
tional Planning Competitions (IPC) in 2020. However, it was
decided that the ﬁrst version of HDDL would not include
any of the temporal or numerical features of PDDL due to
efforts to develop the language and related tools. In this pa-
per, we illustrate the challenge of deﬁning the semantics for
a temporal extension of HDDL to meet the needs of the plan-
ning community and planning applications.
Our motivation is grounded on the compelling need to
devise applications involving autonomous systems. We pro-
pose to extend HDDL, by including elements of PDDL 2.1
and ANML (Action Notation Modeling Language) (Smith,
Frank, and Cushing 2008), to express temporal and numeri-
cal constraints. This is intended to initiate discussions within
the HTN community on establishing a standard – HDDL
2.1 – aimed at ﬁlling the gaps between existing hierarchical-
temporal planning approaches. To that end, we make this
preliminary extension of HDDL an open source project with
a public repository, where we propose a full syntax as well as
a set of benchmarks based on this extension1 and a parser for
it, as part of the PDDL4J2 library (Pellier and Fiorino 2018).
The rest of the paper is organised as follows. In Section
2 we deﬁne the basic concepts of the proposed extension. In
Sections 3 and 4 we set down the semantics for Temporal
1https://github.com/pellierd/HDDL2.1
2https://github.com/pellierd/pddl4j


--- Page 2 ---
HTN planning. We conclude on the central aspects of this
planning paradigm, and on future work.
2
Lifted Temporal HTN planning
Throughoutthis section, we will use common notations from
ﬁrst-order logic, which we assume to be known. In the lifted
formalism of HDDL 2.1, we assume for the sake of sim-
plicity that all logical formulas are over a function-free ﬁrst-
order logic language L = (V, C, P). L consists of sufﬁ-
ciently many constant c ∈C representing the objects in the
real world, variables x ∈V and predicates p ∈P. Predi-
cates have parameters that are either variables or constants.
The predicate arity is the number of predicate parameters.
For instance, p(x, c) is a 2-arity predicate. We can now de-
ﬁne formulas in a function-free ﬁrst-order logic: (i) a pred-
icate is a formula ; (ii) if φ and ψ are formulas, then ¬φ,
φ ∨ψ and φ ∧ψ are formulas ; (iii) if φ is a formula and x is
a variable, then ∀xφ is a formula. We deﬁne ∃xφ as ¬∀x¬φ,
and φ →ψ as ¬φ ∨ψ. ∀and ∃are respectively the uni-
versal and the existential quantiﬁer. Conceptually, ground-
ing a formula consists in generating a set of variable-free
i.e. ground formulas (Helmert 2009) as follows: a variable
x in a quantiﬁer-free formula φ is eliminated by replacing φ
with |C| copies, one for each c ∈C, where x is substituted
with c in the respective copy. This substitution is denoted by
φ[x/c]. Regarding quantiﬁed formulas, ∀xφ is replaced by
V
c∈C φ[x/c] and ∃xφ by W
c∈C φ[x/c]. We refer the reader
to the work of by Behnke et al. (2020); Ramoul et al. (2017)
for further details on grounding implementation. Note that
it is always possible to transform a formula in function-free
ﬁrst-order logic into a ﬁnite set of ground formulas in propo-
sitional logic.
A state s is a set of ground predicates. For the sake of con-
ciseness, we will also consider s as a Herbrand interpretation
that assigns true to all ground predicates in s, and false to
all ground predicates not in s. From this, a truth value can
be computed for every ground formula from L by using the
usual rules for logical composition. Without loss of general-
ity, a formula (not necessarily ground) φ is true in s if and
only if grounding φ generates at least one ground formula
true in s. We will use the notation s |= φ to mean that the
formula φ is true in s.
A key concept in HTN planning and a fortiori in temporal
HTN planning is the concept of task. Each task is given by
a name and a list of parameters. We distinguish two kinds
of tasks: the primitive tasks (also called actions), and the
abstract tasks (or compound tasks). Primitive tasks are car-
ried out by durative actions in the sense of classical temporal
planning (Fox and Long 2003), while abstract tasks can be
reﬁned by applying methods that deﬁne the decomposition
of the task into subtasks. The purpose of abstract tasks is not
to induce a state transition. Instead, they refer to a predeﬁned
mapping to one or more tasks that can reﬁne the abstract
task. For instance, in the task of serving a dinner, deliver-
dinner(?food-style, ?place) is the compound task consist-
ing in performing ﬁrst the task of serving the starters, then
the main course, etc. In that sense, deliver-dinner(?food-
style, ?place) can be reﬁned in: ⟨serve-starters(?food-style,
?place), serve-main-course(?food-style, ?place), etc.⟩This
time
δ
pre
eff
start(a)
pre eff
end(a)
inv(a)
Figure 1: Timeline of a durative action a application.
mapping between tasks is achieved by a set of decomposi-
tion methods, namely the methods (Def. 5) and the Temporal
Task Networks (Def. 6).
We ﬁrst deﬁne the planning domain and problem for Tem-
poral HTN Planning.
Deﬁnition
1.
A
planning
domain
D
is
a
tuple
(L, T , J , α, A, M), where L is the ﬁrst-order logic
language, T is the set of tasks, J is the set of task identi-
ﬁers3, α : J →T is the function that maps task identiﬁers
to tasks, A is a set of actions constituted by snap actions
(Def. 3) and durative actions (Def. 4), M is the set of
methods (Def. 5).
The domain implicitly deﬁnes the set of all states S de-
ﬁned over all subsets of all ground predicates in L.
Deﬁnition
2.
A
planning
problem
P
is
a
tuple
(D, s0, w0, g), where D is a planning domain, s0 ∈S
is the initial state, w0 is the initial temporal task network
(not necessary ground), and g is a formula (not necessary
ground) describing the goal.
Let us start by deﬁning the concepts of snap and durative
actions, which are the primitive tasks, based on the deﬁni-
tions from Abdulaziz and Koller (2022). A snap action is an
action whose execution is instantaneous in the sense of clas-
sical planning, meaning that it has a null duration between
checking the preconditions and applying the effects.
Deﬁnition 3 (Snap Action). A snap action a is a tu-
ple
 name(a), precond(a), effect(a)

, where name(a) is the
name of a, the precondition precond(a) is a ﬁrst-order for-
mula, and the effects effect(a) = effect+(a) ∪effect−(a)
(effect+(a) ∩effect−(a) = ∅), effect+(a) and effect−(a) are
conjunctions of predicates.
Deﬁnition 4 (Durative Action). A durative action a is a tuple
 name(a), start(a), end(a), inv(a), δ

: name(a) is the name
of a; start(a) and end(a) are snap actions; inv(a) is a ﬁrst-
order formula that must hold in all the states after the exe-
cution of start(a) and until the execution of end(a), and δ
is the duration of a.
Actions do change the state of the world. Durative actions
also change the time of the model, shifting it by a quantity
δ, as shown in Figure 1. State transitions will be formally
deﬁned in Section 3.
Unlike a primitive task, a compound task does not directly
change the world state. A compound task is identiﬁed by a
name and deﬁnes the way other –possibly ordered– tasks (ei-
ther primitive or compound) must be achieved with respect
3Task identiﬁers are arbitrary symbols, which serve as place
holders for the actual tasks they represent. Identiﬁers are needed
because tasks can occur multiple times within the same task net-
work, as we will see below.


--- Page 3 ---
to some constraints in order to reﬁne it. Like primitive tasks,
compound tasks have also a start event and an end event,
which will be associated to dates in Section 3. In this sense,
methods allow to refer tasks to temporal task networks.
Deﬁnition
5
(Method).
A
method
m
is
a
tuple
 name(m), task(m), tn(m)

, where name(m) is the name of
the method, task(m) is the task reﬁned by the method, and
tn(m) is the temporal task network decomposing task(m).
Deﬁnition 6 (Temporal Task Network). A temporal task net-
work w = (I, C) is given by:
• I ⊆J is a set (possibly empty) set of tasks identiﬁers;
• C is the set of constraints, with C =< Co, Cv, Cd, Ct >:
– Co is a set of temporal qualitative ordering constraints
over the start or the end events of the tasks in I.
The possible qualitative temporal ordering are those
from the classical point algebra (Broxvall and Jons-
son 2003): <, ≤, >, ≥, = and ̸=;
– Cv is a set of parameter constraints. Each constraint
can bind two variables to be equal or non-equal, or
similarly bind a variable to a constant;
– Cd is a set of durative constraints over the duration of
the tasks in I;
– Ct is a set of temporal decomposition constraints of the
form (at e φ), expressing that some properties deﬁned
by the formula φ must hold in the state at date e.
The temporal task network w implicitely deﬁnes a temporal
ordered multi-set of tasks T ′ = {α(i) | i ∈I}.
A temporal task network explicits the decomposition of
abstract tasks into subtasks. Note that a temporal task net-
work is ground if all its variables are bound to constants,
and primitive if all its tasks T ′ are primitive.
3
Temporal HTN Planning Semantics
The solution of a temporal HTN planning problem is an ex-
ecutable temporal task network that is obtained from the
problem initial task network by applying method decompo-
sition and constraint satisfaction.
Lifted problems are just a compact representation of their
ground instances. Variable constraints are satisﬁed by the
grounding, so there is no need to use them with ground in-
stances. Therefore, for simplicity, this section deﬁnes the se-
mantics of a lifted problem in terms of its ground instances.
For details on the grounding process, the reader is referred
to (Behnke et al. 2020; Ramoul et al. 2017).
Let us start by deﬁning a temporal sequence of tasks.
Deﬁnition 7 (Temporal Sequence of Tasks). A temporal se-
quence of tasks π over a planning domain D, is a sequence
of tuples ⟨(t0, e0, δ0), . . . , (tn, en, δn)⟩where t0, . . . , tn are
ground tasks deﬁned over T , and for 0 ≤i ≤n, the nat-
ural numbers4 ei ∈N≥0 and δi ∈N≥0 are the starting
date and the duration of the task ti, respectively. For a tem-
poral sequence of tasks π, the set of dates {e | (t, e, δ) ∈
4Rational numbers are used in the deﬁnition from Fox and Long
(2003). However, integers should be used for dates, because using
rationals without adding further conditions can yield to an unde-
cidable planning problem (Barringer, Kuiper, and Pnueli 1986).
π} ∪{e + δ | (t, e, δ) ∈π} induces a sorted sequence
< e0, . . . , en > of happening events of π. A temporal se-
quence of tasks π is primitive if and only if for every task
(t, e, δ) ∈π, t is primitive, i.e. t is carried out by an action
(either snap or durative).
The duration of a task t is generally unbounded, as the
bound would be the sum of the durations of the tasks of
which t is compounded of. Only when a task t is primitive,
then duration(t) is given by the duration δ of the action that
achieves t.
In order to guarantee the exutability of concurrent plans,
in the sense of the “required concurrency” as described by
Cushing, Kambhampati, and Weld (2007), a central notion is
non-interference, i.e. when preconditions and effects of snap
actions do not overlap. We consider that two snap actions
a and b are not interfering if and only if (i) precond(a) ∩
 effect+(b)∪effect−(b)

= ∅, (ii) precond(b)∩
 effect+(a)∪
effect−(a)

= ∅, (iii) effect+(a) ∩effect−(b) = ∅and
effect+(b) ∩effect−(a) = ∅.
Two snap actions or more can be executed at the same
time if they are pairwise non-interfering. The execution se-
mantics of snap actions are similar to the semantics of ∀-step
parallel plans (Rintanen, Heljanko, and Niemel¨a 2006), and
used in PDDL 2.1 (Fox and Long 2003). With this notion in
mind, we deﬁne an executable temporal sequence of tasks.
Deﬁnition 8 (Executable Temporal Sequence of Tasks).
A temporal sequence of tasks π
=
⟨(t0, e0, δ0), . . . ,
(tn, en, δn)⟩is executable in a state s0 if and only if for
every (t, e, δ) ∈π: (i) t is primitive; (ii) e is a hap-
pening event of π; (iii) state si at date ei transitions to
a new state si+1 s.t.: given the set Bei of snap actions
being executed at ei: Bei
=

start(aj) | (aj, ej, δj) ∈
π and ej
=
ei} ∪{end(ak)|(ak, ek, δk)
∈
π and
ei + δk
=
ek
	
and given the set Iei of the invari-
ants holding at ei: Iei =

inv(aj) | (aj, ej, δj) ∈π ∧
ej
<
ei
<
ej + δj
	
the transition of si to si+1,
given that all the snap actions in Bei are pairwise non-
interfering, is deﬁned as si |= precond(a) for every a ∈
Bei, si
|=
inv(a) for every inv(a)
∈
Iei
and
si+1 =
 si −∪a∈Bei effect−(a)
 S
a∈Bei effect+(a).
Deﬁnition 8 can be extended to a temporal task network.
Deﬁnition 9 (Executable Temporal Task Network). A tem-
poral task network w = (I, <Co, Cv, Cd, Ct>) is executable
in a state s0 if and only if there exists an executable temporal
sequence of tasks π = ⟨(α(i0), e0, δ0), . . . , (α(in), en, δn)⟩
where i0, . . . , in are task identiﬁers in I that matches the
following conditions: (i) π matches the temporal constraints
Co, (ii) π matches the duration constraints Cd, and (iii) the
sequence of states and their associated dates ⟨(s0, e0), . . . ,
(sn, en)⟩resulting from the execution of π matches the con-
straints Ct.
It remains to deﬁne how to transform a temporal task net-
work into another one by using method decomposition in
order to obtain an executable task network, and what repre-
sents a temporal task network solution.


--- Page 4 ---
Deﬁnition 10 (Decomposition). A task network w1
=
(I1, C1) is decomposed into a new task network w2 =
(I2, C2) by reﬁnement by a method m
=
 name(m),
task(m), (Im, Cm)

if and only if there exists i ∈I1 such
that α(i) = task(m) and I2 = (I1 −{i}) ∪Im, and
C2
o = C1
o ∪Cm
o
∪{start(t) ≤start(t′) | t = min
 estart(α(i)), estart(α(j))

,
t′ = max
 estart(α(i)), estart(α(j))

, j ∈Im}
∪{end(t) ≥end(t′) | t = max
 estart(α(i)), estart(α(j))

,
t′ = min
 estart(α(i)), estart(α(j))

, j ∈Im }
with estart(α(k)) the start date of α(k) for k ∈I1 ∪I2.
C2
v = C1
v ∪Cm
v , C2
d = C1
d ∪Cm
d , C2
t = C1
t ∪Cm
t
Deﬁnition 11 (Temporal Task Network Solution). Let
P
= (D, s0, w0, g) be a planning problem with D =
(L, T , A, M). A task network ws = (I, C) is solution to
a temporal HTN planning problem P if and only if:
• There exists a sequence of decompositions from wo to ws
resulting from the application of the methods M of D;
• ws is executable and the temporal sequence of states re-
sulting from its execution starts with s0, and achieves a
state s |= g.
4
Decomposition Constraint Semantics
Decomposition constraints are conditions that must be satis-
ﬁed by all the states visited while executing a solution task
network. They are expressed through temporal modal oper-
ators over ﬁrst-order formulas involving state predicates, as
in PDDL. The semantics of the decomposition constraints
can be formally speciﬁed similarly to the approach taken
by Gerevini and Long (2005). Let w = (I, C) be a ground
task network, a state s0 and a primitive temporal sequence
of tasks π
=
⟨(t0, e0, δ0), . . . , (tn, en, δn)⟩with t0
=
α(i0), . . . , tn = α(in) resulting from the decomposition of
w. We denote by τ = ⟨(s0, e0), . . . , (sn, en)⟩the tempo-
ral sequence of states produced by the execution of π in s0,
ordered according to its happening events, with i ≤0 ≤n.
Decomposition w satisﬁes a constraint (at e φ) ∈Ct iff
∃(sk, ek) ∈τ such that sk |= φ. Note that it is required that
every temporal constraint of the form (at ei φ) ∈Ct to be
deﬁned for 0 ≤i ≤n so as to avoid deﬁning constraints that
are out of the scope of the temporal task network w. Each de-
composition constraint deﬁned in HDDL 2.1 can be rewrit-
ten in terms of constraints of the form (at e φ). The proposed
HDDL extension distinguishes two types of decomposition
constraints: (1)the temporal decomposition constraints that
deﬁne the constraints that must hold at speciﬁc happen-
ing events whose semantics is based on the plan trajectory
constraints from PDDL 3.0 (Gerevini and Long 2005) and
(2) the classical decomposition constraints (before, after,
between) used in HTN planning (Erol, Hendler, and Nau
1994) to represent constraints between tasks.
For the temporal decomposition constraints, we sug-
gest to keep the same syntax and semantics as intro-
duced in PDDL 3.0 to mantain a language consistency be-
tween different versions. For classical decomposition con-
straints, it can be shown that they can be expressed in
terms of the former, as are method precondition semantics
(at start, at end, overall).
5
Discussion and Conclusion
We have introduced the main features of a HDDL version for
hierarchical temporal planning tasks. This aims at bridging
the gap between HTN planning and real world applications,
where temporal features like concurrent actions, coordina-
tion, and hierarchical distribution of tasks, are prominent.
In our view, the absence of a uniﬁed language for tempo-
ral and numerical constraints in PDDL’s evolution is an ob-
stacle that needs addressing. Although the community has
developed various approaches to model complex planning
problems, including temporal features and hierarchical task
decomposition, the variety of language solutions hinders the
development of common tools and solvers.
Action Notation Modeling Language (ANML) (Smith,
Frank, and Cushing 2008) has an expressivity close to what
we seek here. In ANML effects that happen at time intervals
during an action duration can be speciﬁed. This can also be
represented in HDDL 2.1 by using constraint semantics and
dividing actions with intermediate effects into separate du-
rative actions.
Some planners propose benchmarks where ordering con-
straints are delayed, e.g., FAPE (Dvor´ak et al. 2014). For
instance in ANML it is possible to specify that an action
must happen at least some amount of time after the end of
a previous action. With the proposed syntax and semantics,
such expressivity can be reached by using auxiliary tasks
that decompose in a durative primitive task (of the desired
duration) with no effects.
Time sampling represents another open question for this
extension of HDDL with time. Basically, two approaches
exist. Sampling can be either constant —when time is di-
vided into regular-spaced discrete steps— or with variable
time steps instantiated when effects and preconditions are
applied. The latter can beneﬁt from the Simple Temporal
Problem formalism to model the temporal features of the
plan and to include timed initial effects, and Interval Tem-
poral Logic can be used to deﬁne truth of formulas relative to
time intervals, rather than time points (Bresolin et al. 2014).
In order to be fully compatible with PDDL 3.0 features,
the language HDDL 2.1 needs to include axioms and pref-
erences, besides the associated parsing and validation tools.
For this reason, the present work has to be seen as a base-
line for the planning community to build upon. In fact, many
applications require features that have been (on purpose)
omitted in this paper. Most importantly, we did not explic-
itly report a syntax, and we did not allow to deﬁne delays
with point algebra for ordering constraints. Other features
are simply not detailed here, e.g., continuous effects. Such
language elements are left as natural extension of this paper
for future work.


--- Page 5 ---
References
Abdulaziz, M.; and Koller, L. 2022. Formal Semantics and
Formally Veriﬁed Validation for Temporal Planning.
In
AAAI, 9635–9643.
Alford, R.; Kuter, U.; and Nau, D. 2009. Translating HTNs
to PDDL: A Small Amount of Domain Knowledge Can Go
a Long Way. In IJCAI, 1629–1634.
Alford, R.; Shivashankar, V.; Roberts, M.; Frank, J.; and
Aha, D. 2016.Hierarchical Planning: Relating Task and Goal
Decomposition with Task Sharing. In IJCAI, 3022–3029.
Barringer, H.; Kuiper, R.; and Pnueli, A. 1986.
A really
abstract concurrent model and its temporal logic. In ACM
SIGACT-SIGPLAN symposium on Principles of program-
ming languages, 173–183.
Behnke, G. 2021. Block Compression and Invariant Pruning
for SAT-based Totally-Ordered HTN Planning. In ICAPS,
25–35.
Behnke, G.; H¨oller, D.; Bercher, P.; Biundo, S.; Pellier, D.;
Fiorino, H.; and Alford, R. 2019. Hierarchical planning in
the IPC. In ICAPS Workshop on the International Planning
Competition.
Behnke, G.; H¨oller, D.; and Biundo, S. 2018.
totSAT-
Totally-ordered hierarchical planning through SAT.
In
AAAI, volume 32.
Behnke, G.; H¨oller, D.; and Biundo, S. 2019. Bringing order
to chaos–A compact representation of partial order in SAT-
based HTN planning. In AAAI, volume 33, 7520–7529.
Behnke, G.; H¨oller, D.; Schmid, A.; Bercher, P.; and Biundo,
S. 2020. On Succinct Groundings of HTN Planning Prob-
lems. In AAAI, 9775–9784.
Behnke, G.; Pollitt, F.; H¨oller, D.; Bercher, P.; and Alford,
R. 2022. Making Translations to Classical Planning Com-
petitive with Other HTN Planners. In AAAI, 9687–9697.
Bercher, P.; Alford, R.; and H¨oller, D. 2019. A Survey on
Hierarchical Planning - One Abstract Idea, Many Concrete
Realizations. In IJCAI, 6267–6275.
Bercher, P.; Behnke, G.; H¨oller, D.; and Biundo, S. 2017. An
Admissible HTN Planning Heuristic. In IJCAI, 480–488.
Bit-Monnot, A.; Smith, D.; and Do, M. 2016. Delete-Free
Reachability Analysis for Temporal and Hierarchical Plan-
ning. In ECAI, volume 285, 1698–1699.
Bresolin, D.; Della Monica, D.; Montanari, A.; Sala, P.; and
Sciavicco, G. 2014. Interval temporal logics over strongly
discrete linear orders: Expressiveness and complexity. The-
oretical Computer Science, 560: 269–291.
Broxvall, M.; and Jonsson, P. 2003. Point algebras for tem-
poral reasoning: Algorithms and complexity. Artif. Intell.,
149(2): 179–220.
Cushing, W.; Kambhampati, S.; and Weld, D. S. 2007. When
is temporal planning really temporal? In IJCAI, 1852–1859.
Dvor´ak, F.; Bart´ak, R.; Bit-Monnot, A.; Ingrand, F.; and
Ghallab, M. 2014. Planning and Acting with Temporal and
Hierarchical Decomposition Models. In ICTAI, 115–121.
Erol, K.; Hendler, J.; and Nau, D. 1994. HTN Planning:
Complexity and Expressivity. In AAAI, 1123–1128.
Fox, M.; and Long, D. 2003. PDDL2.1: An Extension to
PDDL for Expressing Temporal Planning Domains. Int. J.
of Artif. Intell. Res., 20: 61–124.
Georgievski, I.; Nizamic, F.; Lazovik, A.; and Aiello, M.
2017. Cloud Ready Applications Composed via HTN Plan-
ning. In IEEE Conference on Service-Oriented Computing
and Applications, 81–89.
Gerevini, A.; and Long, D. 2005. Plan constraints and pref-
erences in PDDL3 - the language of the ﬁfth International
Planning Competition. Technical Report 2005-08-07, De-
partment of Electronics for Automation (Imperial College).
Ghallab, M.; Nau, D.; and Traverso, P. 2016. Automated
Planning and Acting. Cambridge University Press. Chap. 4.
Helmert, M. 2009. Concise ﬁnite-domain representations
for PDDL planning tasks. Artif. Intell., 173(5-6): 503–535.
H¨oller, D.; Behnke, G.; Bercher, P.; Biundo, S.; Fiorino, H.;
Pellier, D.; and Alford, R. 2020. HDDL: An Extension to
PDDL for Expressing Hierarchical Planning Problems. In
AAAI, 9883–9891.
H¨oller, D.; and Bercher, P. 2021. Landmark Generation in
HTN Planning. In AAAI, 11826–11834.
H¨oller, D.; Bercher, P.; Behnke, G.; and Biundo, S. 2019. On
Guiding Search in HTN Planning with Classical Planning
Heuristics. In IJCAI, 6171–6175.
Mcdermott, D.; Ghallab, M.; Howe, A.; Knoblock, C.; Ram,
A.; Veloso, M.; Weld, D.; and Wilkins, D. 1998. PDDL -
The Planning Domain Deﬁnition Language. Technical re-
port, CVC TR-98-003/DCS TR-1165, Yale Center for Com-
putational Vision and Control.
Menif, A.; Jacopin, E.; and Cazenave, T. 2014.
SHPE:
HTN Planning for Video Games. In Workshop on Computer
Games, 119–132.
Milot, A.; Chauveau, E.; Lacroix, S.; and Lesire, C. 2021.
Solving Hierarchical Auctions with HTN Planning.
In
ICAPS Workshop on Hierarchical Planning.
Pellier, D.; and Fiorino, H. 2018. PDDL4J: a planning do-
main description library for Java. J. Exp. Theor. Artif. Intell.,
30(1): 143–176.
Ramoul, A.; Pellier, D.; Fiorino, H.; and Pesty, S. 2017.
Grounding of HTN Planning Domain. Int. J. of Artif. Intell.
Tools, 26(5).
Rintanen, J.; Heljanko, K.; and Niemel¨a, I. 2006.
Plan-
ning as satisﬁability: parallel plans and algorithms for plan
search. Artif. Intell., 170(12-13): 1031–1080.
Schreiber, D. 2021. Lilotane: A Lifted SAT-based Approach
to Hierarchical Planning. J. of Artif. Intell. Res., 70: 1117–
1181.
Schreiber, D.; Pellier, D.; Fiorino, H.; and Balyo, T. 2019.
Tree-REX: SAT-Based Tree Exploration for Efﬁcient and
High-Quality HTN Planning. In ICAPS, 382–390.
Shivashankar, V.; Alford, R.; and Aha, D. 2017. Incorporat-
ing Domain-Independent Planning Heuristics in Hierarchi-
cal Planning. In AAAI, 3658–3664.
Smith, D.; Frank, J.; and Cushing, W. 2008. The ANML
Language. In ICAPS Workshop on Knowledge Engineering
for Planning and Scheduling.
